I"u<h1 id="元编程相关博文的目录及链接">元编程相关博文的目录及链接</h1>
<p>这篇博文是元编程系列博文中的其中一篇、这个系列中其他博文的目录和连接见下：</p>

<ol>
  <li><a href="https://halfclock.github.io/2019/06/01/python-property/">使用 python 特性管理实例属性</a></li>
  <li><a href="https://halfclock.github.io/2019/06/03/python-descriptor_01/">浅析 python 属性描述符（上）</a></li>
  <li><a href="https://halfclock.github.io/2019/06/04/python-descriptor_02/">浅析 python 属性描述符（下）</a></li>
  <li><a href="https://halfclock.github.io/2019/06/07/python-import-and-running/``">python 导入时与运行时</a></li>
  <li><a href="https://halfclock.github.io/2019/06/09/python-metacoding/">python 元编程之动态属性</a></li>
  <li><a href="https://halfclock.github.io/2019/06/10/python-class-metacoding/">python 元编程之类元编程</a></li>
</ol>

<h1 id="review">Review</h1>
<p>上一篇博文，我们论述了 python 属性描述符相比于 property 的优势。</p>

<p>使用属性描述符不仅能够保持 property 的优点，比如，在用通过 “ . “ 访问属性的同时使用一定逻辑进行验证，还具有 property 不具备的优势。</p>

<p>首先、建立属性描述符类能够将其实例赋给多个需要<strong>同样验证逻辑</strong>的托管类属性。</p>

<p>其次、<strong>属性描述符能够使用继承来扩展</strong>，进一步的减少代码冗余。</p>

<p>实际上、property 也是一类属性描述符，即覆盖型描述符。接下来，我们来认识属性描述符的具体分类。</p>

<h1 id="描述符类型简述">描述符类型简述</h1>

<p>在上一篇博文中，介绍描述符类时，我提到过描述符的定义，即<strong>实现了描述符协议的类</strong>。</p>

<p><strong>描述符协议</strong>有三个: <code class="highlighter-rouge">__get__</code>、<code class="highlighter-rouge">__set__</code>、<code class="highlighter-rouge">__delete__</code>、只要类实现了其中的某一个方法，那么这个类就成为了描述符类。</p>

<p>实际上、<strong>根据类是否实现 <code class="highlighter-rouge">__set__</code> 方法、描述符分为覆盖型描述符和费覆盖型描述符</strong>，他们有着不同的性质和应用。</p>

<p>覆盖型描述符<strong>可以不实现 <code class="highlighter-rouge">__get__</code> 方法</strong>。</p>

<p>下面这几个类分别展示了各类描述符：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Overriding</span><span class="p">:</span>  <span class="c1"># 覆盖型描述符
</span>    <span class="s">"""数据描述符或强制描述符"""</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"get——&gt;"</span><span class="o">+</span><span class="s">"Overriding"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"set——&gt;"</span> <span class="o">+</span> <span class="s">"Overriding"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OverridingNoGet</span><span class="p">:</span>  <span class="c1"># 没实现 get 的覆盖型描述符
</span>    <span class="s">"""没有``__get__``方法的覆盖型描述符"""</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"set——&gt;"</span> <span class="o">+</span> <span class="s">"OverridingNoGet"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">NonOverriding</span><span class="p">:</span>  <span class="c1"># 非覆盖型描述符
</span>    <span class="s">"""也称非数据描述符或遮盖型描述符"""</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">owner</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"get——&gt;"</span> <span class="o">+</span> <span class="s">"NonOverriding"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Managed</span><span class="p">:</span>  <span class="c1"># 托管类实例，用于测试各类描述符的行为
</span>    <span class="n">over</span> <span class="o">=</span> <span class="n">Overriding</span><span class="p">()</span>
    <span class="n">over_no_get</span> <span class="o">=</span> <span class="n">OverridingNoGet</span><span class="p">()</span>
    <span class="n">non_over</span> <span class="o">=</span> <span class="n">NonOverriding</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>上面的代码中、Overriding 是覆盖型描述符与上一篇博文中的 Quantity 和 property 是同类型。OverridingNoGet 是没有实现 <code class="highlighter-rouge">__get__</code> 方法的覆盖型描述符。NonOverriding 是非覆盖型描述符，其没有 <code class="highlighter-rouge">__set__</code> 方法。</p>

<p><strong>Managed 是托管类实例，用于接下类测试各类描述符的行为。</strong></p>

<h1 id="覆盖型描述符">覆盖型描述符</h1>

<p>接下来通过代码测试来查看覆盖类描述符的性质：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">Managed</span><span class="p">()</span> <span class="c1"># 1
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over</span> <span class="c1"># 2
</span><span class="n">get</span><span class="err">——</span><span class="o">&gt;</span><span class="n">Overriding</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Managed</span><span class="o">.</span><span class="n">over</span> <span class="c1"># 3
</span><span class="n">get</span><span class="err">——</span><span class="o">&gt;</span><span class="n">Overriding</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1"># 4
</span><span class="nb">set</span><span class="err">——</span><span class="o">&gt;</span><span class="n">Overriding</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over</span> <span class="c1"># 5
</span><span class="n">get</span><span class="err">——</span><span class="o">&gt;</span><span class="n">Overriding</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'over'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span> <span class="c1"># 6
</span><span class="o">&gt;&gt;&gt;</span> <span class="nb">vars</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="c1"># 7
</span><span class="p">{</span><span class="s">'over'</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over</span> <span class="c1"># 8
</span><span class="n">get</span><span class="err">——</span><span class="o">&gt;</span><span class="n">Overriding</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Managed</span><span class="o">.</span><span class="n">over</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1"># 9
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over</span> <span class="c1"># 10
</span><span class="mi">8</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>解释：</strong></p>
<ol>
  <li>新建托管类 Managed 实例 obj <strong>用于测试</strong>。</li>
  <li>实例 <strong>obj.over 会触发描述符实例的 <code class="highlighter-rouge">__get__</code> 方法</strong>。</li>
  <li>托管类直接访问 over 属性也会触发描述符的<code class="highlighter-rouge">__get__</code> 方法。</li>
  <li>为 obj.over 赋值，会触发描述符实例的 <code class="highlighter-rouge">__set__</code> 方法。</li>
  <li>赋值后，使用实例访问 over 依旧会访问描述符实例的 <code class="highlighter-rouge">__get__</code> 方法。</li>
  <li>使用实例的 <code class="highlighter-rouge">__dict__</code> 属性直接创建实例属性 over ，并为其赋值</li>
  <li>通过 <code class="highlighter-rouge">vars()</code> 查看实例属性，发现实例属性中有 <code class="highlighter-rouge">over</code>，且其值为刚才赋予的 8.</li>
  <li>obj.over 依旧访问描述符实例的 <code class="highlighter-rouge">__get__</code> 方法。</li>
  <li>尝试使用 7 将类属性 over 覆盖</li>
  <li>现在 obj.over 返回 8，而不是访问描述符实例的 <code class="highlighter-rouge">__get__</code> 方法了。</li>
</ol>

<blockquote>
  <p>在理解上例时，请结合上一篇博文的描述符工作流程图一同理解。</p>
</blockquote>

<h4 id="覆盖型描述符性质总结">覆盖型描述符性质总结</h4>

<p>首先、<strong>不管使用 obj.over 还是 Managed.over 都会访问到描述符实例的 <code class="highlighter-rouge">__get__</code> 方法。</strong></p>

<p>其次、obj.over = 7 会调用描述符实例的 <code class="highlighter-rouge">__set__</code> 方法。</p>

<p><strong>就算通过 <code class="highlighter-rouge">__dict__</code> 直接给实例的 over 属性赋值，其实例的 over 属性也会被描述符实例(Managed 类属性)覆盖</strong>，再次调用 obj.over 依旧会访问描述符实例的 <code class="highlighter-rouge">__get__</code> 方法。</p>

<p>Managed.over = 7 与 obj.over = 7 不同，其<strong>不会调用</strong>描述符实例的 <code class="highlighter-rouge">__set__</code> 方法，而是会将 Managed 类属性（描述符实例）覆盖掉，再次调用 obj.over 访问的就是实例属性了。</p>

<h1 id="无-__get__-的覆盖型描述符">无 <code class="highlighter-rouge">__get__</code> 的覆盖型描述符</h1>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over_no_get</span> <span class="c1"># 1
</span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">OverridingNoGet</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x1100be8d0</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Managed</span><span class="o">.</span><span class="n">over_no_get</span> <span class="c1"># 2
</span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">OverridingNoGet</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x1100be8d0</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over_no_get</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1"># 3
</span><span class="nb">set</span><span class="err">——</span><span class="o">&gt;</span><span class="n">OverridingNoGet</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over_no_get</span> <span class="c1"># 4
</span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">OverridingNoGet</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x1100be8d0</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'over_no_get'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span> <span class="c1"># 5
</span><span class="o">&gt;&gt;&gt;</span> <span class="nb">vars</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="c1"># 6
</span><span class="p">{</span><span class="s">'over'</span><span class="p">:</span> <span class="mi">9</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over_no_get</span> <span class="c1"># 7
</span><span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Managed</span><span class="o">.</span><span class="n">over_no_get</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">OverridingNoGet</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x1100be8d0</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over_no_get</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1"># 8
</span><span class="nb">set</span><span class="err">——</span><span class="o">&gt;</span><span class="n">OverridingNoGet</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over_no_get</span> <span class="c1"># 9
</span><span class="mi">9</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Managed</span><span class="o">.</span><span class="n">over_no_get</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1"># 10
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over_no_get</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># 11
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">over_no_get</span> <span class="c1"># 12
</span><span class="mi">10</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>解释：</strong></p>

<ol>
  <li>使用 <code class="highlighter-rouge">obj.over_no_get</code> , 会<strong>返回描述符实例对象。</strong></li>
  <li>使用 <code class="highlighter-rouge">Managed.over_no_get</code> ，也会返回描述符实例对象。</li>
  <li><code class="highlighter-rouge">obj.over_no_get = 7</code> 会调用描述符实例的 <code class="highlighter-rouge">__set__</code> 方法。</li>
  <li>再次调用 <code class="highlighter-rouge">obj.over_no_get</code> 依旧返回描述符实例对象，<strong>说明 <code class="highlighter-rouge">obj.over_no_get = 7</code> 不会覆盖描述符实例。</strong></li>
  <li><code class="highlighter-rouge">obj.__dict__['over'] = 9</code> 使用实例的 <code class="highlighter-rouge">__dict__</code> 属性<strong>直接创建实例属性 over_no_get ，并为其赋值为 9</strong>。</li>
  <li>通过 <code class="highlighter-rouge">vars()</code> 查看实例属性、发现实例属性中有 <code class="highlighter-rouge">over_no_get</code>，且其值为刚才赋予的 9。</li>
  <li><strong>再次通过 <code class="highlighter-rouge">obj.over_no_get</code> , 发现现在不返回描述符实例对象了，其返回的是实例属性的值 —— 9。</strong></li>
  <li>再次调用 <code class="highlighter-rouge">obj.over_no_get = 7</code> ,<strong>依旧调用描述符实例的 <code class="highlighter-rouge">__set__</code> 方法。</strong></li>
  <li>使用 <code class="highlighter-rouge">obj.over_no_get</code> 查看，发现其没有受到刚才调用 <code class="highlighter-rouge">obj.over_no_get = 7</code> 的影响。</li>
  <li>尝试使用 7 将类属性 over_no_get 覆盖</li>
  <li>调用 <code class="highlighter-rouge">obj.over_no_get = 10</code> 发现<strong>已经不调用描述符实例的 <code class="highlighter-rouge">__set__</code> 方法了。</strong></li>
  <li>发现上面的 <code class="highlighter-rouge">obj.over_no_get = 10</code> 对实例属性赋值了。现在的 <code class="highlighter-rouge">obj.over_no_get</code> 的值是10。</li>
</ol>

<h4 id="无-__get__-覆盖型描述符总结">无 <code class="highlighter-rouge">__get__</code> 覆盖型描述符总结</h4>
<p>首先、因为无 <code class="highlighter-rouge">__get__</code> 覆盖型描述符没有 <code class="highlighter-rouge">__get__</code> 方法、当其托管类实例没有对应的实例属性时，我们使用 <code class="highlighter-rouge">obj.over_no_get</code> 或者 <code class="highlighter-rouge">Managed.over_no_get</code> 拿到的是描述符实例。</p>

<p>其次，当托管类实例有对应的实例属性时，使用 <code class="highlighter-rouge">obj.over_no_get</code> 拿到的就是实例属性了，而使用 <code class="highlighter-rouge">Managed.over_no_get</code> 拿到还是描述符实例。</p>

<p><code class="highlighter-rouge">obj.over_no_get = 7</code> 与有 <code class="highlighter-rouge">__get__</code> 覆盖型描述符行为一致。</p>

<p>调用 <code class="highlighter-rouge">Managed.over_no_get = 7</code> 也会将 Managed 类属性（描述符实例）覆盖掉。
再次调用 <code class="highlighter-rouge">obj.over_no_get = 7</code> 就不会调用 <code class="highlighter-rouge">__set__</code>了，而是给实例属性赋值。</p>

<h1 id="覆盖型描述符工作流程">覆盖型描述符工作流程</h1>

<h4 id="objattr--value-的工作流"><code class="highlighter-rouge">obj.attr = value</code> 的工作流</h4>

<p>因为覆盖型描述符都实现了 <code class="highlighter-rouge">__set__</code> magic 方法，<strong>所以<code class="highlighter-rouge">obj.attr = value</code> 的工作流很简单、就是直接访问描述符实例的 <code class="highlighter-rouge">__set__</code> magic 方法。</strong></p>

<blockquote>
  <p>上面的例子中，当调用了 <code class="highlighter-rouge">Managed.over_no_get = 7</code> 后，再调用<code class="highlighter-rouge">obj.over_no_get = 7</code> 就不会调用描述符实例的 <code class="highlighter-rouge">__set__</code>。</p>

  <p>其原因是，此时 Managed 类的 over_no_get 类属性承载的已经不是描述符实例了，而是 7。</p>
</blockquote>

<h4 id="objattr-的工作流"><code class="highlighter-rouge">obj.attr</code> 的工作流</h4>

<p><code class="highlighter-rouge">obj.attr</code> 的工作流，根据描述符有无 <code class="highlighter-rouge">__get__</code> 而不同，具体看下面的流程图：
<img src="/img/in-post/post-python-descriptor/Overiding-set-workflow.png" alt="未命名文件 -1-" /></p>
<h1 id="非覆盖型描述符">非覆盖型描述符</h1>
<p>非覆盖型描述符的性质与覆盖型描述符有着很大的区别，它的具体行为可以通过观察下面的测试代码得到：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">non_over</span> <span class="c1"># 1
</span><span class="n">get</span><span class="err">——</span><span class="o">&gt;</span><span class="n">NonOverriding</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Managed</span><span class="o">.</span><span class="n">non_over</span> <span class="c1"># 2
</span><span class="n">get</span><span class="err">——</span><span class="o">&gt;</span><span class="n">NonOverriding</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">non_over</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1"># 3
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">non_over</span> <span class="c1"># 4
</span><span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">vars</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="c1"># 5
</span><span class="p">{</span><span class="s">'non_over'</span><span class="p">:</span> <span class="mi">7</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">'non_over'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">9</span> <span class="c1"># 6
</span><span class="o">&gt;&gt;&gt;</span> <span class="nb">vars</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="c1"># 7
</span><span class="p">{</span><span class="s">'non_over'</span><span class="p">:</span> <span class="mi">9</span><span class="p">}</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Managed</span><span class="o">.</span><span class="n">non_over</span> <span class="c1"># 8
</span><span class="n">get</span><span class="err">——</span><span class="o">&gt;</span><span class="n">NonOverriding</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">Managed</span><span class="o">.</span><span class="n">non_over</span> <span class="o">=</span> <span class="mi">7</span> <span class="c1"># 9
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">Managed</span><span class="o">.</span><span class="n">non_over</span> <span class="c1"># 10
</span><span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">obj</span><span class="o">.</span><span class="n">non_over</span> <span class="c1"># 11
</span><span class="mi">9</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ol>
  <li>当实例没有 non_over 实例属性，直接调用描述符实例的 <code class="highlighter-rouge">__get__</code> 方法。</li>
  <li>直接访问类的 non_over 属性，也会直接调用描述符实例的 <code class="highlighter-rouge">__get__</code> 方法。</li>
  <li>现在尝试调用 <code class="highlighter-rouge">obj.non_over = 7</code> ，看在描述符实例没有 <code class="highlighter-rouge">__set__</code> 时，解释器如何执行。</li>
  <li>从访问结果来看、调用 <code class="highlighter-rouge">obj.non_over</code> 访问的是实例属性。</li>
  <li>通过 vars 查看实例属性，发现的确如此。</li>
  <li>尝试使用 <code class="highlighter-rouge">__dict__</code> 直接修改实例属性</li>
  <li>发现第三步的 <code class="highlighter-rouge">obj.non_over = 7</code> 与使用 <code class="highlighter-rouge">__dict__</code> 直接修改没有差别。</li>
  <li>现在直接访问类的 non_over 属性，依然访问描述符实例的 <code class="highlighter-rouge">__get__</code> 方法。</li>
  <li>尝试将类的 non_over 属性覆盖掉。</li>
  <li>覆盖类属性成功。</li>
  <li>对类属性赋的值对实例属性没有影响。(普通的类也有这种行为，即实例属性会覆盖类属性)</li>
</ol>

<h4 id="非覆盖型描述符总结">非覆盖型描述符总结</h4>

<p>非覆盖型描述符与覆盖型描述符区别很大，最大的区别在于其<strong>因为没有实现 <code class="highlighter-rouge">__set__</code> 方法</strong>，所以在调用类似 <code class="highlighter-rouge">obj.non_over = 7</code> 时会直接对实例属性赋值。</p>

<p>还有一个区别是，当实例有 <code class="highlighter-rouge">non_over</code> 属性时，就算描述符实现了 <code class="highlighter-rouge">__get__</code> 方法，<code class="highlighter-rouge">obj.non_over</code> <strong>还是会直接访问实例属性。</strong></p>

<p>这与覆盖型描述符完全不同，<strong>覆盖型描述符</strong>在实现了 <code class="highlighter-rouge">__get__</code> 方法的情况下，<code class="highlighter-rouge">obj.non_over</code> <strong>无论如何都会执行 <code class="highlighter-rouge">__get__</code> 方法</strong>。</p>

<blockquote>
  <p>非覆盖型描述符从实例属性搜索，而覆盖型描述符从类属性搜索。</p>
</blockquote>

<p>可能会有点绕，可以直接通过下面的非覆盖型描述符的 <code class="highlighter-rouge">obj.attr</code> 流程图来感受区别：</p>

<p><img src="/img/in-post/post-python-descriptor/NonOverriding-workflow.png" alt="未命名文件 -2-" />
看到了吗？<strong>非覆盖型描述符首先搜索的是实例中有无 attr 实例属性，没有采取搜索托管类的属性描述符；</strong> 而覆盖型描述符首先搜索的是托管类。</p>

<blockquote>
  <p>非覆盖的意思也就显而易见了，即属性描述符的 <code class="highlighter-rouge">__get__</code> 方法无法覆盖实例属性。</p>
</blockquote>

<p>对于非覆盖型描述符 <code class="highlighter-rouge">obj.attr = value</code> 的工作流不言而喻，因为其没有实现 <code class="highlighter-rouge">__set__</code> 方法，<strong>所以无论如何都会给实例属性 attr 赋 value 值。</strong></p>

<h1 id="各类描述符的使用场景">各类描述符的使用场景</h1>

<h4 id="全覆盖型描述符">全覆盖型描述符</h4>
<blockquote>
  <p>这里指实现了 <code class="highlighter-rouge">__set__</code> 和 <code class="highlighter-rouge">__get__</code> 协议的描述符。</p>
</blockquote>

<p>能够使用全覆盖型描述符的场景，通常<strong>还需要考虑是否使用特性。</strong>这部分可以参照上一篇博文最后的总结。</p>

<p>此类描述符还有另一个使用的场景，即<strong>只读属性</strong>，只读属性的 <code class="highlighter-rouge">__set__</code> 只需要抛出指定的异常即可。</p>

<p>必须设置 <code class="highlighter-rouge">__get__</code> 的原因是，防止用户使用 <code class="highlighter-rouge">__dict__</code> 直接对实例属性进行修改，因为覆盖型描述符不管是否有实例属性，在读值时都会访问 <code class="highlighter-rouge">__get__</code> 方法。</p>

<h4 id="半覆盖型描述符">半覆盖型描述符</h4>
<blockquote>
  <p>这里指没有 <code class="highlighter-rouge">__get__</code> 方法的覆盖型描述符。</p>
</blockquote>

<p><strong>此类描述符通常用于验证属性。</strong></p>

<p>即检查用户给的 value 是否符合系统定义的规则，如果符合规则，才将之存储至实例属性中，当需要拿到实例属性时，不用通过 <code class="highlighter-rouge">__get__</code> ，直接访问实例属性即可能快速的拿到需要的值。</p>

<h4 id="非覆盖型描述符-1">非覆盖型描述符</h4>
<blockquote>
  <p>这里指没有 <code class="highlighter-rouge">__set__</code> 方法的覆盖型描述符。</p>
</blockquote>

<p><strong>此类描述符适合使用在第一次访问需要加载数据（花费时间长）的场景。———— 高效缓存</strong></p>

<p>因为第一次访问实例属性时，调用描述符实例的 <code class="highlighter-rouge">__get__</code> 方法，在该方法中加载数据，然后将加载完成的数据(value)，使用 obj. attr = value 赋给实例属性。</p>

<p>之后再访问实例属性就无需加载数据，不再访问描述符实例的 <code class="highlighter-rouge">__get__</code> 方法了，直接访问实例属性即可。</p>

<h1 id="总结">总结</h1>
<p>本篇博文与上一篇博文总结了属性描述符是什么、怎么使用、以及何时使用的问题。</p>

<p>指出了属性描述符是<strong>实现了描述符协议的类</strong>、其<strong>实例通常被托管类类属性所承载</strong>、并且根据是否实现 <code class="highlighter-rouge">__set__</code> 方法，<strong>分为覆盖型描述符和非覆盖型描述符，他们分别应用于只读属性、属性验证和高效缓存中。</strong></p>

<p>本文也进一步的揭示了，属性描述符相对于特性( property )的优势，<strong>无 <code class="highlighter-rouge">__get__</code> 的覆盖型描述符</strong>和<strong>非覆盖型描述符</strong>能在特性无法应用的场景中如鱼得水。</p>

<p>下一篇博文，将解释 python 语言在导入时和运行时解释器所做的事情，理解它们的区别对于观察元编程的性质而言有着很大的用处。</p>
:ET